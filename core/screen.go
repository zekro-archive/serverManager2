package core

import (
	"fmt"
	"io/ioutil"
	"os"
	"os/exec"
	"regexp"
	"strings"
	"time"

	"../util"
)

var LogLocation = "/etc/servermanager/logs/"

type Screen struct {
	Uid               int
	Id, Name, Started string
}

func GetRunningScreens() *[]Screen {
	out, _ := exec.Command("screen", "-ls").Output()
	outsplit := strings.Split(string(out), "\n")
	regex := regexp.MustCompile(`[()]`)

	screens := []Screen{}

	if len(outsplit) > 3 {
		for i, e := range outsplit[1 : len(outsplit)-2] {
			fields := strings.Fields(e)
			nameandid := strings.Split(fields[0], ".")
			screens = append(screens, Screen{
				i,
				nameandid[0],
				nameandid[1],
				regex.ReplaceAllString(fields[1]+" "+fields[2], ""),
			})
		}
	}

	return &screens
}

func GetServers(location string) *[]Screen {
	screens := []Screen{}
	folders, _ := ioutil.ReadDir(location)
	for _, f := range folders {
		if !f.IsDir() {
			continue
		}
		folder := f.Name()
		if strings.HasPrefix(folder, ".") || strings.HasPrefix(folder, "_") {
			continue
		}
		screens = append(screens, Screen{
			Uid:  len(screens),
			Name: folder,
		})
	}
	// filepath.Walk(location, func(path string, info os.FileInfo, err error) error {
	// 	folder := strings.Replace(path, location, "", -1)
	// 	if len(strings.Split(folder, "/")) == 2 {
	// 		if !strings.HasPrefix(folder, "/.") && !strings.HasPrefix(folder, "/_") {
	// 			pstat, _ := os.Stat(path)
	// 			if pstat.Mode().IsDir() {
	// 				screens = append(screens, Screen{
	// 					Uid:  len(screens),
	// 					Name: folder[1:],
	// 				})
	// 			}
	// 		}
	// 	}
	// 	return err
	// })
	return &screens
}

func SliceContainsServer(slc *[]Screen, server *Screen) (bool, *Screen) {
	for _, e := range *slc {
		if e.Name == server.Name {
			return true, &e
		}
	}
	return false, &Screen{}
}

func createRunnerFile(path string) {
	ioutil.WriteFile(path+"/.runner", []byte(
		"# This is a autogenerated file.\n"+
			"# Please, do not delete this file!\n\n"+
			"while true; do bash $1 $2; done"), 0644)
}

func setupLogging(path, screenName string) string {
	logpath := LogLocation + screenName
	_, err := os.Stat(logpath)
	if os.IsNotExist(err) {
		os.MkdirAll(logpath, os.ModePerm)
	}
	_, err = ioutil.ReadFile(path + "/.screenrc")
	if os.IsNotExist(err) {
		err = ioutil.WriteFile(path+"/.screenrc", []byte(
			"# This is a autogenerated file.\n"+
				"# Please, do not delete this file!\n\n"+
				fmt.Sprintf("logfile %s/%s_%s", logpath, screenName, time.Now().Format("01-02-06_15-04-05"))), 0644)
	}
	return path + "/.screenrc"
}

func getStartFile(serverLocation, screenName string) (bool, string) {
	startfile := serverLocation + "/" + screenName + "/run.sh"

	_, err := ioutil.ReadFile(startfile)
	if os.IsNotExist(err) {
		util.LogError("This server has no 'run.sh' file specified.\n" +
			"Please create this file in the root directory of the server with the command to start.")
		util.Pause()
		return false, err.Error()
	} else if err != nil {
		util.LogError("An unexpected error occured opening 'run.sh' of this server:\n" + err.Error())
		util.Pause()
		return false, err.Error()
	}
	return true, startfile
}

// SCREEN ACTION FUNCTIONS

func StartScreen(screen *Screen, screens *[]Screen, config *util.Conf, runInLoop bool) bool {
	var err error
	if ok, _ := SliceContainsServer(screens, screen); ok {
		util.LogError("Screen '" + screen.Name + "' is still running!")
		util.Pause()
		return false
	}

	location := config.ServerLocation + "/" + screen.Name
	ok, startfile := getStartFile(config.ServerLocation, screen.Name)
	if !ok {
		return false
	}

	if runInLoop {
		createRunnerFile(location)
		if config.Logging > 0 {
			err = exec.Command("screen", "-dmLS", screen.Name, "-c", setupLogging(location, screen.Name), "bash", location+"/.runner", startfile, location).Run()
			return err == nil
		}
		err = exec.Command("screen", "-dmS", screen.Name, "bash", location+"/.runner", startfile, location).Run()
	} else {
		if config.Logging > 0 {
			err = exec.Command("screen", "-dmLS", screen.Name, "-c", setupLogging(location, screen.Name), "bash", startfile, location).Run()
			return err == nil
		}
		err = exec.Command("screen", "-dmS", screen.Name, "bash", startfile, location).Run()
	}
	return err == nil
}

func StopScreen(screen *Screen, screens *[]Screen, config *util.Conf) bool {
	if ok, _ := SliceContainsServer(screens, screen); !ok {
		util.LogError("Screen '" + screen.Name + "' is not running!")
		util.Pause()
		return false
	}

	err := exec.Command("screen", "-XS", screen.Name, "quit").Run()
	return err == nil
}

func ResumeScreen(screen *Screen, screens *[]Screen, config *util.Conf) {
	if ok, _ := SliceContainsServer(screens, screen); !ok {
		util.LogError("Screen '" + screen.Name + "' is not running!")
		util.Pause()
		return
	}

	cmd := exec.Command("screen", "-r", screen.Name)
	cmd.Stdout = os.Stdout
	cmd.Stdin = os.Stdin
	cmd.Run()
}

func RestartScreen(screen *Screen, screens *[]Screen, config *util.Conf, runInLoop bool) {
	location := config.ServerLocation + "/" + screen.Name
	ok, startfile := getStartFile(config.ServerLocation, screen.Name)
	if !ok {
		return
	}

	if ok, _ := SliceContainsServer(screens, screen); ok {
		exec.Command("screen", "-XS", screen.Name, "quit").Run()
	}

	if runInLoop {
		createRunnerFile(location)
		if config.Logging > 0 {
			exec.Command("screen", "-dmLS", screen.Name, "-c", setupLogging(location, screen.Name), "bash", location+"/.runner", startfile, location).Run()
			return
		}
		exec.Command("screen", "-dmS", screen.Name, "bash", location+"/.runner", startfile, location).Run()
	} else {
		if config.Logging > 0 {
			exec.Command("screen", "-dmLS", screen.Name, "-c", setupLogging(location, screen.Name), "bash", startfile, location).Run()
			return
		}
		exec.Command("screen", "-dmS", screen.Name, "bash", startfile, location).Run()
	}
}
